"""
ActionTrace data model definitions.

Aligns with Unity EditorEvent and EventStore data structures.
Provides type-safe serialization and deserialization support.

Design principles:
- Python side is responsible only for data validation and type conversion
- Business logic (summary generation, semantic analysis) is done by C# side
- Configuration is obtained from C# side, no hardcoded default values
"""
from typing import Any, Optional
from pydantic import BaseModel, Field


class EditorEvent(BaseModel):
    """
    Unity editor event data model.

    Corresponds to Unity side MCPForUnity.Editor.ActionTrace.Core.EditorEvent.

    Fields are generated by C# side, Python side only handles validation and type conversion.

    C# side JsonProperty mappings:
    - Sequence -> "sequence"
    - TimestampUnixMs -> "timestamp_unix_ms"
    - Type -> "type"
    - TargetId -> "target_id"
    - Payload -> "payload"
    - PrecomputedSummary -> "summary" (via GetSummary())

    Simplified (aligned with C# ActionTraceViewResource):
    - Removed context fields (has_context, context) - not supported
    - Kept semantic fields (importance_score, importance_category, inferred_intent)
    """
    sequence: int = Field(..., description="Monotonically increasing sequence number for sorting")
    timestamp_unix_ms: int = Field(..., description="UTC timestamp (milliseconds)")
    type: str = Field(..., description="Event type identifier")
    target_id: str = Field(..., description="Target identifier (instance ID, asset GUID, or file path)")
    payload: Optional[dict[str, Any]] = Field(None, description="Event payload containing additional context data")
    summary: Optional[str] = Field(None, description="Event summary generated by C# side")
    is_dehydrated: Optional[bool] = Field(None, description="Whether event payload is dehydrated (memory optimization)")

    # Semantic fields (returned when include_semantics=True)
    importance_score: Optional[float] = Field(None, description="Importance score (0.0-1.0)")
    importance_category: Optional[str] = Field(None, description="Importance category (low/medium/high/critical)")
    inferred_intent: Optional[str] = Field(None, description="Inferred operation intent")

    class Config:
        """Pydantic configuration"""
        populate_by_name = True  # Allow using aliases


class EventQueryResult(BaseModel):
    """
    Event query result.

    Corresponds to the response format returned by C# side.
    Simplified (aligned with C# ActionTraceViewResource).
    """
    events: list[EditorEvent] = Field(default_factory=list, description="Event list")
    total_count: int = Field(0, description="Total event count")
    current_sequence: Optional[int] = Field(None, description="Current sequence number")
    has_more: Optional[bool] = Field(None, description="Whether more events exist")
    schema_version: Optional[str] = Field(None, description="Schema version")


class EventStatistics(BaseModel):
    """
    Event statistics.

    Calculated by Python side based on data returned from C#.
    """
    total_events: int = Field(default=0, description="Total event count")
    events_by_type: dict[str, int] = Field(default_factory=dict, description="Event count grouped by type")
    oldest_event_sequence: Optional[int] = Field(default=None, description="Oldest event sequence number")
    newest_event_sequence: Optional[int] = Field(default=None, description="Newest event sequence number")
    time_span_ms: Optional[int] = Field(default=None, description="Time span (milliseconds)")
    dehydrated_count: int = Field(default=0, description="Count of dehydrated events")
    hydrated_count: int = Field(default=0, description="Count of hydrated events")


class ActionTraceSettings(BaseModel):
    """
    ActionTrace system settings.

    Actual configuration obtained from C# side, no hardcoded default values.
    """
    schema_version: str = Field(..., description="Schema version")

    # Event filtering
    min_importance_for_recording: float = Field(..., description="Minimum importance threshold for recording events")
    disabled_event_types: list[str] = Field(default_factory=list, description="List of disabled event types")

    # Event merging
    enable_event_merging: bool = Field(..., description="Whether event merging is enabled")
    merge_window_ms: int = Field(..., description="Event merging time window (milliseconds)")

    # Storage limits
    max_events: int = Field(..., description="Maximum event count")
    hot_event_count: int = Field(..., description="Hot event count (retains full payload)")

    # Transaction aggregation
    transaction_window_ms: int = Field(..., description="Transaction aggregation time window (milliseconds)")

    # Current storage status
    current_sequence: int = Field(..., description="Current sequence number")
    total_events_stored: int = Field(..., description="Total events stored")
    context_mapping_count: int = Field(..., description="Context mapping count")


class TransactionInfo(BaseModel):
    """
    Transaction information.

    Represents a group of related operation sequences (aggregation mode).
    """
    start_sequence: int = Field(..., description="Start event sequence number")
    end_sequence: int = Field(..., description="End event sequence number")
    summary: str = Field(..., description="Transaction summary")
    event_count: int = Field(..., description="Number of events included")
    duration_ms: int = Field(..., description="Duration (milliseconds)")
    tool_call_id: Optional[str] = Field(None, description="Tool call ID that triggered this transaction")
    triggered_by_tool: Optional[str] = Field(None, description="Tool name that triggered this transaction")
