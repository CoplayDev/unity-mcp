"""
ActionTrace resources for querying Unity editor operation history.

Provides access to:
- Event history (GameObject, Component, Property, Asset, Scene operations)
- Event statistics (by type, time span, memory usage)
- System settings (from C# side, no hardcoded defaults)

Design principles:
- Python side handles data transfer and validation only
- Business logic (summarization, semantics) is done by C# side
- Configuration is fetched from C# side, not hardcoded
"""
from typing import Annotated, Any, Literal, Optional

from fastmcp import Context
from mcp.types import ToolAnnotations

from models import MCPResponse
from models.action_trace import (
    EditorEvent,
    EventQueryResult,
    EventStatistics,
    ActionTraceSettings,
)
from services.registry import mcp_for_unity_resource
from services.tools import get_unity_instance_from_context
import transport.unity_transport as unity_transport
from transport.legacy.unity_connection import async_send_command_with_retry


@mcp_for_unity_resource(
    uri="mcpforunity://action_trace{?limit,since_sequence,min_importance}",
    name="action_trace",
    description="Query Unity editor action trace (operation history). Returns events with summaries generated by C# side.",
)
async def get_action_trace(
    ctx: Context,
    limit: Annotated[int, "Maximum number of events to return (1-1000, default 50)"] = 50,
    since_sequence: Annotated[Optional[int],
        "Only return events after this sequence number (for incremental queries)"] = None,
    event_types: Annotated[Optional[list[str]],
        "Filter by event types (e.g., ['GameObjectCreated', 'ComponentAdded'])"] = None,
    include_payload: Annotated[bool,
        "Whether to include full event payload"] = True,
    include_context: Annotated[bool,
        "Whether to include context associations"] = False,
    include_semantics: Annotated[bool,
        "Whether to include semantic analysis (importance, category, intent)"] = False,
    min_importance: Annotated[Literal["low", "medium", "high", "critical"] | None,
        "Minimum importance level (default: medium)"] = None,
    task_id: Annotated[Optional[str], "Filter by task ID"] = None,
    conversation_id: Annotated[Optional[str], "Filter by conversation ID"] = None,
) -> MCPResponse:
    """
    Get Unity editor action trace events.

    Returns events from the Unity editor operation history including:
    - GameObject create/destroy, Component add/remove
    - Property modifications, Asset operations
    - Scene save/load, Play mode changes, AI notes

    The summary field is generated by the C# side (EventSummarizer).
    """
    unity_instance = get_unity_instance_from_context(ctx)

    # Build query parameters
    params: dict[str, Any] = {
        "limit": limit,
        "include_payload": include_payload,
        "include_context": include_context,
        "include_semantics": include_semantics,
    }

    if since_sequence is not None:
        params["since_sequence"] = since_sequence

    if event_types is not None and len(event_types) > 0:
        params["event_types"] = event_types

    if min_importance is not None:
        params["min_importance"] = min_importance

    if task_id is not None:
        params["task_id"] = task_id

    if conversation_id is not None:
        params["conversation_id"] = conversation_id

    # Call Unity side
    response = await unity_transport.send_with_unity_instance(
        async_send_command_with_retry,
        unity_instance,
        "get_action_trace",
        params,
    )

    # Handle error response
    if isinstance(response, dict) and not response.get("success", True):
        return MCPResponse(**response)

    # Parse Unity response data
    data = response.get("data") if isinstance(response, dict) else {}
    events_data = data.get("events", []) if isinstance(data, dict) else []

    # Validate and convert events using Pydantic
    events = []
    for event_dict in events_data:
        try:
            event = EditorEvent(**event_dict)
            events.append(event)
        except Exception as e:
            # ctx.error is sync, no await needed
            ctx.error(f"Failed to parse event: {e}")  # type: ignore[reportUnusedCoroutine]
            continue

    # Build query result
    query_result = EventQueryResult(
        events=events,
        total_count=data.get("total_count", len(events)) if isinstance(data, dict) else len(events),
        current_sequence=data.get("current_sequence") if isinstance(data, dict) else None,
        schema_version=data.get("schema_version") if isinstance(data, dict) else None,
        context_mapping_count=data.get("context_mapping_count") if isinstance(data, dict) else None,
        has_more=None,  # C# side doesn't return this yet
    )

    result_data = {
        "query_result": query_result.model_dump(),
    }

    return MCPResponse(
        success=True,
        message=f"Retrieved {len(events)} action trace events",
        data=result_data,
    )


@mcp_for_unity_resource(
    uri="mcpforunity://action_trace/statistics",
    name="action_trace_statistics",
    description="Get ActionTrace event statistics (computed from C# returned data).",
)
async def get_action_trace_statistics(
    ctx: Context,
) -> MCPResponse:
    """
    Get ActionTrace event statistics.

    Statistics include:
    - Total event count, events by type
    - Time span (oldest to newest event)
    - Memory usage (dehydrated/hydrated event counts)
    """
    unity_instance = get_unity_instance_from_context(ctx)

    # Fetch events for statistics
    response = await unity_transport.send_with_unity_instance(
        async_send_command_with_retry,
        unity_instance,
        "get_action_trace",
        {"limit": 1000, "include_payload": False, "include_context": False},
    )

    if isinstance(response, dict) and not response.get("success", True):
        return MCPResponse(**response)

    data = response.get("data") if isinstance(response, dict) else {}
    events_data = data.get("events", []) if isinstance(data, dict) else []

    # Convert events
    events = []
    for event_dict in events_data:
        try:
            event = EditorEvent(**event_dict)
            events.append(event)
        except Exception:
            continue

    # Compute statistics
    statistics = _compute_statistics(events)

    result_data = {
        "statistics": statistics.model_dump() if statistics else None,
    }

    return MCPResponse(
        success=True,
        message="Retrieved action trace statistics",
        data=result_data,
    )


def _compute_statistics(events: list[EditorEvent]) -> EventStatistics:
    """
    Compute event statistics from event list.

    Args:
        events: List of events to analyze

    Returns:
        EventStatistics with computed values
    """
    if not events:
        return EventStatistics()

    # Count by type
    events_by_type: dict[str, int] = {}
    dehydrated_count = 0
    hydrated_count = 0

    for event in events:
        # Count by type
        event_type = event.type
        events_by_type[event_type] = events_by_type.get(event_type, 0) + 1

        # Count dehydration status
        if event.is_dehydrated:
            dehydrated_count += 1
        else:
            hydrated_count += 1

    # Sequence range
    sequences = [e.sequence for e in events]
    oldest_sequence = min(sequences) if sequences else None
    newest_sequence = max(sequences) if sequences else None

    # Time span
    timestamps = [e.timestamp_unix_ms for e in events]
    if len(timestamps) >= 2:
        time_span_ms = int(max(timestamps) - min(timestamps))
    else:
        time_span_ms = None

    return EventStatistics(
        total_events=len(events),
        events_by_type=events_by_type,
        oldest_event_sequence=oldest_sequence,
        newest_event_sequence=newest_sequence,
        time_span_ms=time_span_ms,
        dehydrated_count=dehydrated_count,
        hydrated_count=hydrated_count,
    )


@mcp_for_unity_resource(
    uri="mcpforunity://action_trace/settings",
    name="action_trace_settings",
    description="Get ActionTrace system settings (fetched from C# side, actual values).",
)
async def get_action_trace_settings(
    ctx: Context,
) -> MCPResponse:
    """
    Get ActionTrace system settings.

    Returns live configuration from C# side including:
    - Event filtering (min_importance_for_recording, disabled_event_types)
    - Event merging (enable_event_merging, merge_window_ms)
    - Storage limits (max_events, hot_event_count)
    - Transaction aggregation (transaction_window_ms)
    - Current store state (current_sequence, total_events_stored)
    """
    unity_instance = get_unity_instance_from_context(ctx)

    # Call C# side tool
    response = await unity_transport.send_with_unity_instance(
        async_send_command_with_retry,
        unity_instance,
        "get_action_trace_settings",
        {},
    )

    if isinstance(response, dict) and not response.get("success", True):
        return MCPResponse(**response)

    data = response.get("data") if isinstance(response, dict) else {}

    return MCPResponse(
        success=True,
        message="Retrieved action trace settings",
        data=data,
    )
